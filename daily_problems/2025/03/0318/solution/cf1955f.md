**提示 1：** 把所有删去的数字放成一个数列，则每次删掉一个数时，剩余的是后缀。我们要最大化后缀异或和为 $0$ 的个数。

**提示 2：** 反转上述序列，我们就相当于凑前缀和。怎么凑最“节省”。

先看提示 1 和 2 的转化。我们就相当于把题目中的数排列好，使得前缀和异或为 $0$ 的位置尽可能多。

一种最好凑的方法就是把两个相同的数放过来，这样只要两个数就可以满足要求了。

用上面这种节约的方式尽可能放，最后就只剩下了每种类别的最多一个元素。而剩余的 $4$ 无论如何不可能跟其他数凑出为 $0$ 的异或和，因为它自己最高位就不一样。

因此剩余的数中最多只有 $3$ 个数 “有效”。而如果小于三个数，无法多凑出一组 $0$ ，因为整个序列的异或和一定非 $0$ 。

如果恰好多出来了 $1,2,3$ ，此时最多只可能多凑一组 $1\mathrm{xor}2\mathrm{xor}3=0$ ，只需检查是否多出这么一组就行。

当然，你也可以只使用 $1,2,3$ 数字的出现频率进行 DP 预处理，后续查询，但就有些复杂化了。

时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []

    for _ in range(t):
        a, b, c, d = MII()
        outs.append(a // 2 + b // 2 + c // 2 + d // 2 + (a & b & c & 1))

    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        cout << (a / 2 + b / 2 + c / 2 + d / 2 + (a & b & c & 1)) << '\n';
    }

    return 0;
}
```
