**提示 1：** 实际上气球放法并不多。

**提示 2：** 先把底下的气球放好，再看上面的余量。

直接把气球从下往上堆——前面每层都两个气球，最后一层 1 个或 2 个，这就是这题需要考虑的所有情况了。

那么我们先用 $h$ 尽可能放多排——总共放了 $\lfloor h/r\rfloor$ 排，共计 $2\lfloor h/r\rfloor$ 个气球。

由于上面有个可以放一个气球的半圆，因此答案至少加一。接下来 $h$ 表示高度余量。

可能加 $2$ 吗？答案是肯定的，只需剩余的高度余量达到了 $\frac{r}{2}$ 。

可能加 $3$ 吗？这就意味着多了一排，又多了一个气球。这就要求总高度为 $r+\frac{\sqrt{3}}{2}r$ （连接圆心有个边长为 $r$ 的等边三角形，高是 $\frac{\sqrt{3}}{2}r$ ，再加上上面和下面的两个半径 $\frac{1}{2}r$ ）。此时要求 $r+h$ ，即剩余部分的总高度，至少为 $r+\frac{\sqrt{3}}{2}r$ ，即判断 $h$ 和 $\frac{\sqrt{3}}{2}r$ 的大小关系，这个两边平方后可以无精度误差地判断。

可能加 $4$ 吗？此时一定是两排气球，底下的一排要求了 $h\geq r$ ，这与我们一开始已经尽可能两个两个放气球了矛盾，我们原来安排的气球剩余的高度余量一定小于 $r$ 。

从下往上依次判断，即可判断最多能新增多少气球。

时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    r, h = MII()
    ans = h // r * 2
    h %= r

    if h * h * 4 >= r * r * 3: ans += 3
    elif h * 2 >= r: ans += 2
    else: ans += 1

    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int r, h;
    cin >> r >> h;

    int ans = h / r * 2;
    h %= r;

    if (4ll * h * h >= 3ll * r * r) ans += 3;
    else if (h * 2 >= r) ans += 2;
    else ans ++;

    cout << ans;

    return 0;
}
```
