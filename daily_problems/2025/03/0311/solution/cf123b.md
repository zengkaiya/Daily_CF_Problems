**提示 1：** 给出的两个条件其实是两组直线。

**提示 2：** 我们要最少地穿越直线。

如果无法直接想象给出的条件是一系列的直线，你可以分别画出 $x+y=0,2a,-2a,4a,-4a,\dots$ 和 $x-y=0,2b,-2b,4b,-4b,\dots$ 来对这题有更直观的感受。

分别考虑两个方向的直线。如果起点和终点之间有 $k$ 条直线，则至少需要穿过 $k$ 条直线，也就至少走过 $k$ 个不好的点。

设两个方向分别需要走过 $k_1,k_2$ 个点，答案是多少呢？是 $k_1+k_2$ 吗？

这是不正确的：因为我们可以走过两个方向的直线的交点——这样就同时跨过了两个方向的直线。这样可以把数量较小的方向在走另一个方向时全部处理掉，因此答案是 $\max(k_1,k_2)$ 。

计算穿过多少条直线，只需看 $x_1+y_1,x_2+y_2$ 之间有多少 $2a$ 的倍数， $x_1-y_1,x_2-y_2$ 之间有多少 $2b$ 的倍数。

时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    a, b, x1, y1, x2, y2 = MII()
    print(fmax(abs((x1 + y1) // (2 * a) - (x2 + y2) // (2 * a)),
            abs((x1 - y1) // (2 * b) - (x2 - y2) // (2 * b))))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int a, b, x1, y1, x2, y2;
    cin >> a >> b >> x1 >> y1 >> x2 >> y2;

    auto div = [&] (int a, int b) -> int {
        int x = a / b;
        if (b * x > a) x --;
        return x;
    };

    cout << max(abs(div(x1 + y1, 2 * a) - div(x2 + y2, 2 * a)),
                abs(div(x1 - y1, 2 * b) - div(x2 - y2, 2 * b)));

    return 0;
}
```
